schema {
  query: QueryRoot
}

type FilterInversionSolution {
  analysis: InversionSolutionAnalysis
}

"""
Represents the internal details of a given solution or filtered solution
"""
type InversionSolutionAnalysis {
  solution_id: ID
  fault_sections: [InversionSolutionFaultSection]
  ruptures: [InversionSolutionRupture]
  geojson: JSONString
}

"""Defines filter arguments for Inversions analysis"""
input InversionSolutionAnalysisArguments {
  """The ID of the InversionSolution"""
  solution_id: ID!

  """
  Optional list of locations codes for proximity filtering e.g. `WLG,PMR,ZQN`
  """
  location_codes: [String]

  """The rupture/location intersection radius in km"""
  radius_km: Int

  """Constrain to ruptures having a annual rate above the value supplied."""
  minimum_rate: Float

  """Constrain to ruptures having a annual rate below the value supplied."""
  maximum_rate: Float

  """Constrain to ruptures having a magnitude above the value supplied."""
  minimum_mag: Float

  """Constrain to ruptures having a magnitude below the value supplied."""
  maximum_mag: Float
}

type InversionSolutionFaultSection {
  """Unique ID of the fault section eg WHV1"""
  fault_id: String
}

type InversionSolutionRupture {
  """Unique ID of the rupture within this solution"""
  fault_id: Int

  """rupture magnitude"""
  magnitude: Float
}

"""
Allows use of a JSON String for input / output from the GraphQL schema.

Use of this type is *not recommended* as you lose the benefits of having a defined, static
schema (one of the key benefits of GraphQL).
"""
scalar JSONString

"""An object with an ID"""
interface Node {
  """The ID of the object."""
  id: ID!
}

"""This is the entry point for solvis graphql query operations"""
type QueryRoot {
  node(
    """The ID of the object"""
    id: ID!
  ): Node

  """About this Solvis API """
  about: String
  analyse_solution(input: InversionSolutionAnalysisArguments!): FilterInversionSolution
}

